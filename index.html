<!DOCTYPE html>
<html>

<head>
    <title>Departures</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        input {
            enabled: false;
        }
        #map {
            height: 90%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    Latitute:  <input id="latitude"></input>
    Longitude: <input id="longitude"></input>
    Zoom:    <input id="zoom"></input>
    <button onclick="view.centerCurrentPosition()">Center</button>
</body>

<script type="text/javascript">

var log = {

    debug: function () {
        this.emit(" DEBUG ", arguments);
    },

    info: function () {
        this.emit(" INFO  ", arguments);
    },

    warning: function() {
        this.emit("WARNING", arguments);
    },

    error: function() {
        this.emit(" ERROR ", arguments);
    },

    emit: function(level, args) {
        stringified = [];
        for(var i in args) {
            stringified.push(JSON.stringify(args[i]))
        }
        console.log(level + " | " + stringified.join(" "))
    }
};

function Model() {
    this.bounds = {
        sw: {lat: 56.163357, lng: 10.216666},
        ne :{lat: 56.163357, lng: 10.216666}
    };
    this.stops = {};
    this.currentStop = null;
    this.buses = [];
    this.transit = [{"url": "https://transit.land", "name": "test", "location": {"lat": null, "lng": null}}];
    this.zoom = 15;
    this.routes = {};
}

Model.prototype.setBounds = function(bounds) {
    if (
        this.bounds.east == bounds.east &&
        this.bounds.north == bounds.north &&
        this.bounds.west == bounds.west &&
        this.bounds.south == bounds.south
    ) {
        return false;
    } else {
        this.bounds = bounds;
        return true
    }
}

Model.prototype.getCenter = function() {
    return {
        lat: (this.bounds.south + this.bounds.north) * 0.5,
        lng: (this.bounds.east + this.bounds.west) * 0.5
    }
}

Model.prototype.setZoom = function(zoom) {
    this.zoom = zoom
}

Model.prototype.pushStop = function(stop) {
    var stopId = stop.stopId;
    this.stops[stop.stopId] = stop;
}

Model.prototype.setCurrentStop = function(stopId) {
    if (stopId != this.currentStop) {
        this.currentStop = stopId;
        this.buses = [];
        return true;
    }
}

Model.prototype.getCurrentStop = function() {
    return this.stops[this.currentStop];
}

Model.prototype.pushBus = function(bus) {
    this.buses.push(bus);
}

Model.prototype.sortBuses = function() {
    this.buses.sort(
        function(bus1, bus2) {
            return bus1.time - bus2.time;
        }
    );
}

Model.prototype.pushRoute = function(route) {
    var routeId = route.routeId;
    if(route.routeId in this.routes) {
        for(key in route) {
            this.routes[route.routeId][key] = route[key];
        }
    } else {
        this.routes[route.routeId] = route;
    }
}

function Presenter(view, model) {
    this.model = model;
    this.view = view;
    this.transit = new TransitClient(model.transit);
    this._stopRequested = false;
    this._updateCurrentStopRequested = false;
    this.MIN_ZOOM = 15;
}

Presenter.prototype.centerCurrentPosition = function() {
    if (navigator.geolocation) {
        var self = this;
        log.debug("Get user position...");
        navigator.geolocation.getCurrentPosition(
            function (position) {
                self.view.centerPosition({
                    lat: position.coords.latitude,
                    lng: position.coords.longitude
                });
            },
            log.error
        );
    } else {
        log.error("Geolocation is not supported by your browser.");
    }
}

Presenter.prototype.setBounds = function(bounds) {
    if (this.model.setBounds(bounds)) {
        if (this.model.zoom >= this.MIN_ZOOM) {
            log.debug("Set bounds:", this.model.bounds);
            if (!this._stopRequested) {
                this._stopRequested = true;
                self = this;
                window.setTimeout(function() {self.requestStops()}, 500.);
            }
        }
        this.view.updateCenter();
    } else {
        log.debug("Same location.");
    }
}

Presenter.prototype.setZoom = function(zoom) {
    if (zoom < this.MIN_ZOOM) {
        this.view.removeMarkers()
    }

    this.model.setZoom(zoom);
    this.view.updateZoom(zoom);
}

Presenter.prototype.requestStops = function() {
    log.debug("Get stops:", this.model.bounds);
    var self = this;
    this.transit.requestStops(
        this.model.bounds,
        function(stops) {self.receiveStops(stops)}
    ).send();
    this._stopRequested = false;
}

Presenter.prototype.receiveStops = function(stops) {
    for (var i in stops) {
        var stopEntry = stops[i];
        // log.debug("Parse bus stop:", stopEntry);

        var routes = [];
        for(j in stopEntry.routes_serving_stop) {
            var routeEntry = stopEntry.routes_serving_stop[j];
            route = {
                routeId: routeEntry.route_onestop_id,
                name: routeEntry.route_name
            }
            this.model.pushRoute(route);
            routes.push(route.routeId);
        }

        var stopId = stopEntry.onestop_id;
        var lonLat = stopEntry.geometry.coordinates;
        var stop = {
            stopId: stopId,
            lat: lonLat[1],
            lng: lonLat[0],
            name: stops[i].name,
            routes: routes,
        };
        this.model.pushStop(stop);
        this.dropStopMarker(stopId);
    }
}

Presenter.prototype.dropStopMarker = function(stopId) {
    var self = this;
    function dropMarker() {
        if(self.model.zoom >= self.MIN_ZOOM){
            self.view.dropStopMarker(stopId);
        }
    }
    window.setTimeout(dropMarker, Math.random() * 1000.);
}

Presenter.prototype.setCurrentStop = function(stopId) {
    if(this.model.setCurrentStop(stopId)) {
        if(stopId) {
            this.requestBuses();
            this.requestRoutes();
            this.updateCurrentStop();
        }
    }
}

Presenter.prototype.requestBuses = function(stopId) {
    log.debug("Get buses:", stopId);
    var self = this;
    this.transit.requestBuses(
        this.model.currentStop,
        function(buses) {self.receiveBuses(buses)}
    ).send();
}

Presenter.prototype.receiveBuses = function(buses) {
    for (var i in buses) {
        var now = new Date();
        var timeParts = buses[i].origin_arrival_time.split(':');
        var time = new Date();
        time.setHours(timeParts[0]);
        time.setMinutes(timeParts[1]);
        time.setSeconds(timeParts[2]);
        var deltaTime = time - now;
        if (deltaTime < 0) {
            // increment the time by one day
            time.setDate(time.getDate() + 1);
            deltaTime = time - now;
        }
        var hasService = buses[i].service_days_of_week[time.getDay()];
        if (hasService) {
            var bus = {
                routeId: buses[i].route_onestop_id,
                destinationId: buses[i].destination_onestop_id,
                time: time,
                deltaTime: deltaTime,
            };
            log.debug("Update current buses:", bus);
            this.model.pushBus(bus);
        }
    }
    this.model.sortBuses();
    this.updateCurrentStop();
}

Presenter.prototype.requestRoutes = function(stopId) {
    log.debug("Get routes:", stopId);
    var self = this;
    this.transit.requestRoutes(
        this.model.currentStop,
        function(routes) {self.receiveRoutes(routes)}
    ).send();
}

Presenter.prototype.receiveRoutes = function(routes) {
    var routeIds = [];
    for (var i in routes) {
        var routeEntry = routes[i];
        log.debug("Parse bus route:", routeEntry);

        var stops = [];
        for(i in routeEntry.stop_pattern) {
            stops.push(routeEntry.stop_pattern[i])
        }
        var route = {
            routeId: routeEntry.route_onestop_id,
            stops: stops
        }
        routeIds.push(routeEntry.route_onestop_id);
        this.model.pushRoute(route);
    }
    if(routeIds && routeIds.length > 0) {
        this.requestRouteStops(routeIds);
    }
    this.updateCurrentStop();
}

Presenter.prototype.updateCurrentStop = function(routes) {
    if(this.model.currentStop && !this._updateCurrentStopRequested) {
        this._updateCurrentStopRequested = true;
        var self = this;
        window.setTimeout(
            function() {
                self._updateCurrentStopRequested = false;
                if(self.model.currentStop) {
                    self.view.updateCurrentStop();
                    self.updateCurrentStop();
                }
            },
            1000
        );
    } else {
        this._updateCurrentStopRequested = false;
    }
}

Presenter.prototype.requestRouteStops = function(routeIds) {
    log.debug("Get stops for routes:", this.model.bounds);
    var self = this;
    this.transit.requestRouteStops(
        routeIds,
        function(stops) {self.receiveStops(stops)}
    ).send();
}
function TransitClient(conf) {
    this.conf = conf;
    this.stopRequest = null;
    this.busRequest = null;
    this.routeRequres = null;
}

TransitClient.prototype.requestStops = function(
        bounds, receiveStops) {
    var request = this.stopRequest;
    if (request) {
        request.stop();
    }
    this.stopRequest = request = new TransitRequest(
        this.getUrl("/api/v1/stops"), {
            bbox: [bounds.west, bounds.south,
                   bounds.east, bounds.north].join(',')
        }
    );
    request.onRensponse = function (response) {
        receiveStops(response.stops);
    }
    return request;
}

TransitClient.prototype.requestBuses = function(
        stopId, receiveBuses) {
    var request = this.busRequest;
    if (request) {
        request.stop();
    }

    this.busRequest = request = new TransitRequest(
        this.getUrl("/api/v1/schedule_stop_pairs"),
        {origin_onestop_id: stopId}
    );
    request.onRensponse = function (response) {
        receiveBuses(response.schedule_stop_pairs);
    }
    return request;
}

TransitClient.prototype.requestRoutes = function(
        stopId, receiveRoutes) {
    var request = this.routeRequest;
    if (request) {
        request.stop();
    }

    this.routeRequest = request = new TransitRequest(
        this.getUrl("/api/v1/route_stop_patterns"),
        {stops_visited: stopId}
    );
    request.onRensponse = function (response) {
        receiveRoutes(response.route_stop_patterns);
    }
    return request;
}

TransitClient.prototype.requestRouteStops = function(
        routeIds, receiveStops) {
    var request = this.stopRequest;
    if (request) {
        request.stop();
    }

    this.stopRequest = request = new TransitRequest(
        this.getUrl("/api/v1/stops"), {
            served_by: routeIds.join(',')
        }
    );
    request.onRensponse = function (response) {
        receiveStops(response.stops);
    }
    return request;
}


TransitClient.prototype.getUrl = function(endPoint) {
    return this.conf[0].url + '/' + endPoint
}

// ----------------------------------------------------------------------------

function TransitRequest(url, parameters) {
    this.url = url;
    this.done = false;
    this._request = null;
    this._responses = [];
    var args = [];
    for(var name in parameters) {
        args.push(
            encodeURIComponent(name) + "=" +
            encodeURIComponent(parameters[name])
        );
    }
    if(args.length > 0){
        url += "?" + args.join('&');
    }

    this.url = url;
    this.done = false;
    this._responses = [];
}

TransitRequest.prototype.onRensponse = function(response){
}

TransitRequest.prototype.onDone = function(responses){
}

TransitRequest.prototype.stop = function() {
    if(!this.done) {
        this.done = true;
        this.onDone(this._responses);
    }
}

TransitRequest.prototype.send = function() {
    var request = new XMLHttpRequest();
    var self = this;
    this._request = request;
    log.debug("Send request:", this.url)
    request.open("GET", this.url);
    request.setRequestHeader('Content-Type', 'application/json');
    request.addEventListener(
        'load', function() {self.parseRensponse(request)}
    );
    request.send();
}

TransitRequest.prototype.parseRensponse = function(request) {
    var response = JSON.parse(request.responseText );
    this._responses.push(response);
    this.onRensponse(response);
    if(!this.done){
        var next = response.meta.next;
        if(request == this._request && next) {
            this.url = response.meta.next;
            this.send();
        } else {
            this.stop();
        }
    }
}

function View() {
    this.map = null;
    this.stopMarkers = [];
    this.model = new Model();
    this.presenter = new Presenter(this, this.model);
    this.latitude = document.getElementById('latitude');
    this.longitude = document.getElementById('longitude');
    this.zoom = document.getElementById('zoom');
    this.busWindow = null;
};

View.prototype.centerCurrentPosition = function () {
    this.presenter.centerCurrentPosition();
}

View.prototype.centerPosition = function (position) {
    this.map.setCenter(position);
}

View.prototype.updateCenter = function () {
    if (this.map) {
        var center = this.model.getCenter();
        this.latitude.value = center.lat;
        this.longitude.value = center.lng;
    }
}

View.prototype.updateZoom = function () {
    if (this.map) {
        this.zoom.value = this.model.zoom;
    }
}

View.prototype.initMap = function() {
    this.map = new google.maps.Map(
        document.getElementById('map'),
        {bounds: this.model.bounds, zoom: 16}
    );

    var self = this;

    function boundsChanged() {
        var bounds = self.map.getBounds().toJSON();
        if (!isNaN(bounds.south) && !isNaN(bounds.north) &&
            !isNaN(bounds.east) && !isNaN(bounds.west)) {
            self.presenter.setBounds(bounds);
        }
    }
    this.map.addListener('bounds_changed', boundsChanged);

    function zoomChanged() {
        self.presenter.setZoom(self.map.getZoom());
    }
    zoomChanged();
    this.map.addListener('zoom_changed', zoomChanged);

    var busWindowClosed = function() {
        self.presenter.setCurrentStop(null)
    }
    this.busWindow = new google.maps.InfoWindow();
    this.busWindow.addListener('closeclick', busWindowClosed);
}

View.prototype.dropStopMarker = function(stopId) {
    var marker = this.stopMarkers[stopId]
    if (!marker) {
        log.debug("Drop new stop marker:", stopId);
        this.stopMarkers[stopId] = marker = new google.maps.Marker({
            position: this.model.stops[stopId], map: view.map,
            animation: google.maps.Animation.DROP
        });
        var self = this;
        marker.addListener(
            'click', function() {self.presenter.setCurrentStop(stopId);}
        );
    }
}

View.prototype.removeMarkers = function() {
    oldMarkers = this.stopMarkers;
    this.stopMarkers = {};
    for(i in oldMarkers){
        oldMarkers[i].setMap(null);
    }
}

View.prototype.updateCurrentStop = function() {
    var currentStop = this.model.getCurrentStop();
    var win = this.busWindow;
    if(currentStop && win) {
        var busInfos = [
            "<h3>"+ currentStop.name + "</h3>",
            "<table>",
            "<tr>" +
                "<td><h4>Route</h4></td>" +
                "<td><h4>Destination</h4></td>" +
                "<td><h4>Time</h4></td>" +
            "<tr>",
        ];
        for (var busId in this.model.buses) {
            var bus = this.model.buses[busId];
            var route = this.model.routes[bus.routeId];
            if (route) {
                var routeName = route.name;
                var routeStops = route.stops;
            } else {
                var routeName = bus.routeId.split('-')[2];
                var routeStops = null;
            }

            if(routeStops && routeStops.length > 0) {
                departureIndex = routeStops.indexOf(currentStop.stopId);
                destinationIndex = routeStops.indexOf(bus.destinationId);
                if (departureIndex > destinationIndex) {
                    var finalDestinationId = routeStops[0];
                } else {
                    var finalDestinationId = routeStops[routeStops.length - 1];
                }
            }
            else {
                finalDestinationId = bus.destinationId;
            }

            var destinationStop = this.model.stops[finalDestinationId];
            if (destinationStop) {
                var destinationName = destinationStop.name;
            } else {
                var destinationName = finalDestinationId.split('-')[2];
            }
            var remainingMinutes = Math.ceil(bus.deltaTime / (1000 * 60));
            if (remainingMinutes < 60.) {
                var time = [remainingMinutes, "min."].join(" ")
            } else {
                var time = [
                    bus.time.getHours(),
                    bus.time.getSeconds(),
                    bus.time.getMinutes()
                ].join(':');
            }
            var row = "<tr>" +
                "<td><h5>" + routeName + "</h5></td>" +
                "<td>" + destinationName + "</td>" +
                "<td><h5>" + time + "</h5></td>" +
            "<tr>";
            busInfos.push(row);
        }
        busInfos.push('</table>');
        var newContent = busInfos.join('');
        var oldContent = win.getContent();
        if (newContent != oldContent) {
            win.setContent(newContent);
            win.setPosition(currentStop);
            win.open(this.map);
        }
    }
}

function closeBusesWindow() {
    var win = this.busWindow;
    if (win) {
        win.close();
    }
}

var view = new View();

view.updateCenter();
view.updateZoom();
view.centerCurrentPosition();

</script>

<script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwigDJTs6z4mYFvL8EqvEIecO5jNGq-a4&callback=view.initMap">
</script>

</html>